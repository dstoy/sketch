{"version":3,"file":"runtime.js","sources":["../src/runtime/config.ts","../src/runtime/plugin.ts","../src/runtime/transformer.ts","../src/runtime/index.ts"],"sourcesContent":["export const config: RuntimeConfig = {\n    load: \"pages/**/*\",\n    pages: [],\n\n    /**\n     * Checks if a path is a page\n     */\n    isPage(path: string) {\n        return this.pages.includes(path);\n    },\n};\n\nexport default config;\n\nexport interface RuntimeConfig {\n    load: string;\n    pages: string[];\n    isPage: (path: string) => boolean;\n}\n","/*\n * A vite/rollup plugin for automatically importing all\n * sketch pages into the entry point of the project\n */\nimport glob from \"glob\";\nimport { PluginOption } from \"vite\";\nimport config from \"./config\";\n\nexport default function build() {\n    let importBlock = \"\";\n    let entry: string;\n\n    return {\n        name: \"vite-plugin-sketch\",\n        enforce: \"pre\",\n\n        /**\n         * Get the firs non external loaded file and mark it as the\n         * application entry point\n         */\n        load(id) {\n            if (!entry && !id.includes(\"node_modules\")) {\n                entry = id;\n\n                // Prepare the auto import block\n                config.pages = [];\n                const files = glob.sync(config.load);\n                const chunks = [];\n\n                chunks.push(\n                    `import { router as __sketch_router__ } from \"sketch\";`,\n                );\n\n                for (const file of files) {\n                    const idx = chunks.length;\n                    const pageId = `SketchPage_${idx}`;\n                    config.pages.push(file);\n\n                    chunks.push(`\n                        import * as ${pageId} from \"${file}\";\n                        __sketch_router__.register(${pageId});\n                    `);\n                }\n\n                importBlock = chunks.join(\"\\n\");\n            }\n\n            return null;\n        },\n\n        /**\n         * Transfor the entry point to auto include all pages\n         */\n        transform(code, id) {\n            if (id === entry) {\n                code = code + `\\n\\n${importBlock}`;\n                return code;\n            }\n\n            return null;\n        },\n    } as PluginOption;\n}\n","import { parse, walk } from \"svelte/compiler\";\nimport chalk from \"chalk\";\nimport config from \"./config\";\n\nconst NAME_PROP = \"sketch\";\nconst INDEX_PROP = \"home\";\n\n/**\n * Extract page configuration from the component\n */\nfunction getPageConfig(markup: string): PageConfig {\n    const pageConfig: PageConfig = {};\n\n    // Exctract only the script tags to parse\n    const matches = markup.match(/(<script[\\s\\S]*<\\/script>)/);\n    if (!matches) {\n        return pageConfig;\n    }\n\n    const script = matches[0];\n    const ast = parse(script);\n\n    walk(ast.instance, {\n        enter(node) {\n            if (node.type === \"ExportNamedDeclaration\") {\n                const { declaration } = node;\n                const declarator = declaration.declarations?.find(\n                    (item: any) => item.type === \"VariableDeclarator\",\n                );\n\n                if (declarator) {\n                    const variable = {\n                        name: declarator.id?.name,\n                        value: declarator.init?.value,\n                    };\n\n                    if (variable.name === NAME_PROP) {\n                        pageConfig.name = variable.value;\n                    }\n\n                    if (variable.name === INDEX_PROP) {\n                        pageConfig.home = variable.value;\n                    }\n                }\n            }\n        },\n    });\n\n    return pageConfig;\n}\n\n/**\n * Process a sketch page file and patch it so it auto loads on\n * application start\n */\nfunction process(markup: string, filename: string) {\n    // Extract the page config from the page markup\n    const pageConfig = getPageConfig(markup);\n\n    // Validate the page configuration\n    if (!pageConfig.name) {\n        error(\n            \"Missing page name. \" +\n                \"You can use `export const sketch = '....' to provide it.\",\n            filename,\n        );\n        return markup;\n    }\n\n    // Inject the page registration block\n    const block = `\n        export const __sketch_page_config = {\n            name: \"${pageConfig.name}\",\n            home: ${!!pageConfig.home},\n            file: \"${filename}\",\n        };\n\n        if (import.meta.hot) {\n            window.dispatchEvent(\n                new CustomEvent(\"sketchPageLoad\", {\n                    detail: __sketch_page_config,\n                }),\n            );\n        }\n    `;\n\n    // Make sure we use existing module context if exits. It is not allowed\n    // to have more than one module contexts per component\n    const reg = /^\\s*(<script\\s+context=\"module\"\\s*>)[\\s\\S]*?<\\/script>/gim;\n    const moduleContext = reg.exec(markup);\n\n    if (moduleContext) {\n        markup = markup.replace(\n            moduleContext[1],\n            `${moduleContext[1]}\\n${block}\\n`,\n        );\n    } else {\n        markup = `${markup}\\n\\n<script context=\"module\">\\n${block}\\n</script>`;\n    }\n\n    return markup;\n}\n\n/**\n * Prints an error message\n */\nfunction error(message: string, filename: string) {\n    // eslint-disable-next-line no-console\n    console.error(\n        chalk.red(`failed to load sketch page: ${filename}\\n`) +\n            chalk.red(message),\n    );\n}\n\n/**\n * Transform the page components\n */\nexport default function transformer() {\n    return {\n        async markup({ content, filename }) {\n            if (config.isPage(filename)) {\n                content = process(content, filename);\n            }\n\n            return { code: content };\n        },\n    };\n}\n\ninterface PageConfig {\n    name?: string;\n    home?: boolean;\n}\n","import config, { RuntimeConfig } from \"./config\";\n\nimport plugin from \"./plugin\";\nimport transformer from \"./transformer\";\n\n/**\n * Update the runtime configuiration\n */\nexport function configure(options: Partial<RuntimeConfig>) {\n    for (const [prop, value] of Object.entries(options)) {\n        config[prop] = value;\n    }\n}\n\nexport default {\n    configure,\n    plugin,\n    transformer,\n};\n"],"names":["plugin"],"mappings":";;;MAAa,SAAwB;AAAA,EACjC,MAAM;AAAA,EACN,OAAO;AAAA,EAKP,OAAO,MAAc;WACV,KAAK,MAAM,SAAS;AAAA;AAAA;iBCAH;MACxB,cAAc;MACd;SAEG;AAAA,IACH,MAAM;AAAA,IACN,SAAS;AAAA,IAMT,KAAK,IAAI;UACD,CAAC,SAAS,CAAC,GAAG,SAAS,iBAAiB;gBAChC;eAGD,QAAQ;cACT,QAAQ,KAAK,KAAK,OAAO;cACzB,SAAS;eAER,KACH;mBAGO,QAAQ,OAAO;gBAChB,MAAM,OAAO;gBACb,SAAS,cAAc;iBACtB,MAAM,KAAK;iBAEX,KAAK;AAAA,sCACM,gBAAgB;AAAA,qDACD;AAAA;AAAA;sBAIvB,OAAO,KAAK;AAAA;aAGvB;AAAA;AAAA,IAMX,UAAU,MAAM,IAAI;UACZ,OAAO,OAAO;eACP,OAAO;AAAA;AAAA,EAAO;eACd;AAAA;aAGJ;AAAA;AAAA;AAAA;ACvDnB,MAAM,YAAY;AAClB,MAAM,aAAa;AAKnB,uBAAuB,QAA4B;QACzC,aAAyB;QAGzB,UAAU,OAAO,MAAM;MACzB,CAAC,SAAS;WACH;AAAA;QAGL,SAAS,QAAQ;QACjB,MAAM,MAAM;OAEb,IAAI,UAAU;AAAA,IACf,MAAM,MAAM;;UACJ,KAAK,SAAS,0BAA0B;cAClC,EAAE,gBAAgB;cAClB,aAAa,kBAAY,iBAAZ,mBAA0B,KACzC,CAAC,SAAc,KAAK,SAAS;YAG7B,YAAY;gBACN,WAAW;AAAA,YACb,MAAM,iBAAW,OAAX,mBAAe;AAAA,YACrB,OAAO,iBAAW,SAAX,mBAAiB;AAAA;cAGxB,SAAS,SAAS,WAAW;uBAClB,OAAO,SAAS;AAAA;cAG3B,SAAS,SAAS,YAAY;uBACnB,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;SAOxC;AAAA;AAOX,iBAAiB,QAAgB,UAAkB;QAEzC,aAAa,cAAc;MAG7B,CAAC,WAAW,MAAM;UAEd,+EAEA;WAEG;AAAA;QAIL,QAAQ;AAAA;AAAA,qBAEG,WAAW;AAAA,oBACZ,CAAC,CAAC,WAAW;AAAA,qBACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;QAcX,MAAM;QACN,gBAAgB,IAAI,KAAK;MAE3B,eAAe;aACN,OAAO,QACZ,cAAc,IACd,GAAG,cAAc;AAAA,EAAO;AAAA;AAAA,SAEzB;aACM,GAAG;AAAA;AAAA;AAAA,EAAwC;AAAA;AAAA;SAGjD;AAAA;AAMX,eAAe,SAAiB,UAAkB;UAEtC,MACJ,MAAM,IAAI,+BAA+B;AAAA,KACrC,MAAM,IAAI;AAAA;uBAOgB;SAC3B;AAAA,UACG,OAAO,EAAE,SAAS,YAAY;UAC5B,OAAO,OAAO,WAAW;kBACf,QAAQ,SAAS;AAAA;aAGxB,EAAE,MAAM;AAAA;AAAA;AAAA;mBCpHD,SAAiC;aAC5C,CAAC,MAAM,UAAU,OAAO,QAAQ,UAAU;WAC1C,QAAQ;AAAA;AAAA;AAIvB,YAAe;AAAA,EACX;AAAA,UACAA;AAAAA,EACA;AAAA;;"}